.. _AKMC:

======================================
ADAPTIVE KINETIC MONTE CARLO 
======================================

-------------------------------------------------------------------------------------------------

Kinetic Monte Carlo is a method for simulating the state-to-state dynamics of a rare event system. For dynamics of atomic systems, the rare events correspond to the thermal activation of atoms from one energy basin to another on the potential energy surface. If the rates of these transitions are known, KMC can be used to simulate dynamics over long time scales. The strength of KMC is that the fast vibrational motion of atoms is averaged out, using transition state theory, so that the dynamics can be modelled on the time scale of the thermally activated events.
KMC has some important limitations. The first is that the rates of thermal events needs to be calculated before the simulation begins. This can be done using density functional theory, for example, with the VASP code. For modeling solid systems, rates can be found using harmonic transition state theory. This is a very computationally efficient approximation because only the energy and frequencies of minima and saddle points are needed to find rates of reactions. Adaptive kinetic Monte Carlo is a method for simulating uses saddle point searches to find processes available to the system. Kinetic Monte Carlo is then used to advance the system from state to state.

Here, we present a package that can used to do adaptive kinetic Monte Carlo simulations in VASP. Details of all the algorithms can be found in J. Chem. Phys. 129, 114104 (2008). A manual for using this package is being prepared. You are welcome to ask for help in setting up the simulation.

-------------------------------------------------------------------------------------------------

Setup
======================================

Put the necessary scripts in place:

* | Download the vtstscripts to get the scripts: akmc.pl, dimmins.pl and diminit.pl.
  | Please report bugs to xulijun@u.washington.edu.

* |Three job handling scripts in the same folder: akmc_submit.pl, akmc_check.pl, and akmc_kill.pl  
  |Note: Those file names can't be changed, and you need to write your own scripts since they are specific to the queuing system.

Start with a directory containing:

* config, the parameter file (see below for details)
* POSCAR, initial configuration
* KPOINTS, k-point mesh to sample the Brillouin zone
* POTCAR, pseudopotential file
* INCAR_min, parameters for minimization calculations
* INCAR_sp, parameters for saddle point finding calculations
* INCAR_dymmat, parameters for dynamical matrix calculations
* DISPLACECAR_sp, displacements for initializing dimer searches
* DISPLACECAR, displacements for dynamical matrix calculations
* akmc_min.sub, submission script for minimization jobs
* akmc_sp.sub, submission script for saddle point finding jobs
* akmc_dymmat.sub, submission script for dynamical matrix jobs

Run the script in this directory by typing the command: akmc.pl

Example job, and job related scripts for the SGE queueing system

* (you are strongly recommended to test this example to get familiar with the scripts):

* akmc_sample.tar.gz, the input files for a smaple run

* akmc_submit.pl, a sample submit script

* akmc_check.pl, a sample script to check the status of a job

* akmc_kill.pl, a sample script to kill a job

* cronjob_wrapper, a sample crontab entry to run akmc calculations

-------------------------------------------------------------------------------------------------


Configuration parameters
========================

**MaxJobs**: Maximum number of job to run. For example, if no more than 20 jobs are allowed in the queue (including running jobs) and you are using 5 of them to run other jobs, the maimum number of jobs for akmc must not exceed 15.
	
	Default Value: ``8``

**NumSearches**: Number of good saddle points to be found at each step or the number of searches in the dynamic stopping criteria [see JCP 129, 114104 (2008)]. 
	
	Default Value: ``20``

**AkmcSteps**: Number of kMC steps

        Default Value: ``100000``

**SimR**: in Angstrom, to set up the dimer quenching

        Default Value: ``0.1``

**Ediffmax**: in eV, the energy tolerance for two configurations to be considered as same (subject to Rdiffmax).

        Default Value: ``0.05``

**Rdiffmax**: in Angstrom, the distance tolerance for two configurations to be deemed as same: any atom moves no more than this distance.

        Default Value: ``0.05``

**NumKT**: in Kelvin, the allowed zone in the dynamic stopping criteria

        Default Value: ``20``

**Temperature**: Temperature in Kelvin

        Default Value: ``300.0``

**SearchesAlgo**: Saddle point finding algorithm: dimer or lanzcos

        Default Value: ``dimer``

**BarrierMAX**: the highest barrier allowed (in eV)

        Default Value: ``10``

**JobFile**: a file storing jobs information at each step

        Default Value: ``jobs.dat``

**StFile**: a file storing information for the state "st000x"

        Default Value: ``st.dat``

**AkmcFile**: a file recording each KMC step information

        Default Value: ``akmc.dat``

**DynMatFile**: output file for DymMatrix.pl screen output

        Default Value: ``freq.dat``

**Prefactor**: dynmat calculculation will be turned off if this line is not commented out by placing "#" to the front of this line.

        Default Value: ``1.0e12``

**RateTableFile**: the rate table file for each state

	Default Value: ``RateTableFile.dat``

**OldRunDirFile**: directories where those done states are located; if the is empty, the current akmc folder will be the only directory in which to check for possible repeated states

        Default Value: ``stpool.dat``

**StEnergyFile**: a file containing energy for each completed state, not including the current running state

        Default Value: ``StEnergyFile.dat``

**PrRecycleAll**: if true, before starting a new state, check for quenched processes in previous states to recover good saddles (if any)

        Default Value: ``1``

**PrRecycle**: if true, recycle good saddle points from the state in the previous step

        Default Value: ``1``

**PrRecycleShift**: if true, vector-shift good saddle points from the state in the previous step

        Default Value: ``1``

**GrabQuenched**: if true, check if a saddle has been quenched before in previous states

        Default Value: ``1``

**SurfaceRecShift**: if true, check if the last atomic group is equivalent to the counterpart in previous states. if so, followed by vector-shift

        Default Value: ``1``

**ConvergenceAlgo**: 1: dynamic criteria 0: fixed number of saddle searches

        Default Value: ``1``

**equivalency**: if true, using indistinguishablity in comparing the two states

        Default Value: ``1``

**Screenoutput**: a file containing the screen output.

        Default Value: ``out.dat``

**DisplaceAlgo**: the algorithmm for randomly displacing atoms [see JCP 129, 114104 (2008)]

        Default Value: ``1``

**DisplaceRang**: the radius of the sphere confining the atoms to be displaced.

        Default Value: ``3``

**NN_rcut**: the maximum distance defining two atoms as neighbors

        Default Value: ``2.6``

**MaxCoordNum**: the maximum coordination number (calculated by using NN_rcut) allowed for an atom to be displace based on DisplaceAlgo=1

        Default Value: ``out.dat``

**BoltzmanEqu**: the minimum fraction of a rate constant in the total rate, which is necessary for assuming a Boltzmann equilibrium between two consecutive states.

        Default Value: ``0.99999``

**UseKDB**: if true, preparing dimer searches from a database first before doing random searches.

        Default Value: ``0``

